<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="This is the LaTeX.js editor with live preview.">
  <meta name="keywords" content="LaTeX,LaTeX.js,JavaScript,HTML,editor,live,preview">

  <meta charset="UTF-8">
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta http-equiv="content-language" content="en">

  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <link href="css/playground.css" rel="stylesheet" type="text/css">
  <link href="css/codemirror.css" rel="stylesheet" type="text/css">
  <link href="css/codemirror-monokai.css" rel="stylesheet" type="text/css">

  <script src="js/codemirror.js"></script>
  <script src="js/codemirror-mode-stex.js"></script>

  <script src="js/split.min.js"></script>
  <script src="js/latex-parser.bundle.js"></script>

  <title>LaTeX.js Live Playground</title>
</head>

<body>
  <div id="header">
    <div><span class="latex">L<span>a</span>T<span>e</span>X</span>.js Live Playground</div>
  </div>

  <div id="content">
    <textarea id="latex-editor">
      \section{\LaTeX.js Showcase}

      This document will show most of the supported features of \LaTeX.js.


      \subsection{Characters}

      It is possible to input any UTF-8 character either directly or by character code
      using one of the following:

      \begin{itemize}
          \item \texttt{\textbackslash symbol\{"00A9\}}: \symbol{"00A9}
          \item \texttt{\textbackslash char"A9}: \char"A9
          \item \texttt{\^\^A9 or \^\^\^\^00A9}: ^^A9 or ^^^^00A9
      \end{itemize}

      \bigskip

      Special characters, like those:
      \begin{center}
      \$ \& \% \# \_ \{ \} \~ \^ \textbackslash % \< \>  \" \|   % TODO cannot be typeset
      \end{center}
      %
      have to be escaped.

      Many symbols are accessible through macros. For instance: 30\,\textcelsius{} is
      86\,\textdegree{}F. % TODO: CMU Serif is missing textcelsius!



      \subsection{Spaces and Comments}

      Spaces and comments, of course, work just as they do in \LaTeX.
      This is an            % stupid
      % Better: instructive <----
      example: Supercal%
                    ifragilist%
          icexpialidocious

      It does not matter whether you enter one or several     spaces after a word, it
      will always be typeset as one space---unless you force several spaces, like\ \ now.

      New \TeX users may miss whitespaces after a command. % renders wrong
      Experienced \TeX{} users are \TeX perts, and know how to use whitespaces. % renders correct

      Longer comments can be embedded in the \texttt{comment} environment:
      This is another  \begin  {comment}
      rather stupid,
      but helpful
      \end
      {comment}
      example for embedding comments in your document.



      \subsection{Dashes and Hyphens}

      \LaTeX\ knows four kinds of dashes. Access three of them with different numbers
      of consecutive dashes. The fourth sign is actually not a dash at all---it is the
      mathematical minus sign:\\
      \\
      daughter-in-law, X-rated\\
      pages 13--67\\
      yes---or no? \\
      $0$, $1$ and $-1$\\
      \\
      The names for these dashes are: ‘-’ hyphen, ‘–’ en-dash, ‘—’ em-dash,
      and ‘−’ minus sign. \LaTeX.js outputs the actual true unicode character for those
      instead of using the hypen-minus.



      \subsection{Text and Paragraphs, Ligatures}

      An empty line starts a new paragraph, and so does \texttt{\textbackslash par}.
      \par Like this. A new line usually starts automatically when the previous one is
      full. However, using \texttt{\textbackslash newline} or \texttt{\textbackslash
      \textbackslash},\newline one can force \\ to start a new line.

      Ligatures are supported as well, for instance:

      \begin{center}
      fi, fl, ff, ffi, ffl \dots{} instead of f\/i, f\/l, f\/f\/l \dots
      \end{center}

      Use \texttt{\textbackslash\slash} to prevent a ligature.  % TODO: without tt, it looks horrible...



      \begin{multicols}{2}[\subsection{Multicolumns}]

      The multi-column layout, using the \texttt{multicols} environment, allows easy
      definition of multiple columns of text---just like in newspapers. The first
      and mandatoriy argument specifies the number of columns the text should be divided into.

      It is often convenient to spread some text over all columns, just before the multicolumn
      output. In \LaTeX, this was needed to prevent any page break in between. To achieve this,
      the \texttt{multicols} environment has an optional second argument which can be used for
      this purpose.

      For instance, this text you are reading now was started with the argument
      \texttt{\textbackslash subsection\{Multicolumns\}}.

      \end{multicols}



      \subsection{Spacing}

      The following horizontal spaces are supported:

      Negative thin space: -\negthinspace' \\
      Thin space: -\,- \\
      Thin space: -\thinspace- \\
      Normal space: - - \\
      Normal space: -\ - \\
      Non-break space: -~- \\
      en-space: -\enspace- \\
      em-space: -\quad- \\
      2x em-space: -\qquad-\\
      3cm horizontal space: -\hspace{3cm}- \\



      \subsection{Environments}

      We have already seen two environments: \texttt{itemize} and \texttt{center}. Also
      supported are:

      \begin{enumerate}
      \item \texttt{enumerate}, like this one
      \item \texttt{description}
      \item \texttt{flushleft}
      \item \texttt{flushright}
      \end{enumerate}
      %
      Lists can be nested:
      %
      \begin{itemize}
        \item list text, level one
          \begin{itemize}
            \item list text, level two
              \begin{itemize}
                \item list text, level three

                  And a new paragraph can be started, too.

                \item list text, level three
              \end{itemize}
            \item list text, level two
          \end{itemize}
        \item list text, level one
        \item list text, level one
      \end{itemize}
      %
      The \texttt{flushleft} environment:
      %
      \begin{flushleft}
      This text is\\ left-aligned.
      \LaTeX{} is not trying to make
      each line the same length.
      \end{flushleft}
      %
      The \texttt{flushright} environment:
      %
      \begin{flushright}
      This text is right-\\aligned.
      \LaTeX{} is not trying to make
      each line the same length.
      \end{flushright}
      %
      And the \texttt{center} environment:
      %
      \begin{center}
      At the centre\\of the earth
      \end{center}


      \subsection{Maths}

      Math is typeset using KaTeX. Inline math:
      $
      f(x) = \int_{-\infty}^\infty \hat f(\xi)\,e^{2 \pi i \xi x} \, d\xi
      $
      as well as display math is supported:
      $$
      f(n) = \begin{cases} \frac{n}{2}, & \text{if } n\text{ is even} \\ 3n+1, & \text{if } n\text{ is odd} \end{cases}
      $$


      \subsection{Groups}


      Today is \today.

      Actually, what about { some groups? } They\,are\ \ \ \ \ nice.



      \section{Fonts}

      Usually, \LaTeX.js chooses the right font---just like \LaTeX.  In some cases,
      one might like to change fonts and sizes by hand. To do this, use the standard
      commands. The actual size of each font is a design issue and depends
      on the document class (in this case on the CSS file).

      {\small The small and
        \textbf{bold} Romans ruled}
        {\Large all of great big
        \textit{Italy}.}

      \textit{You can also
        \emph{emphasize} text if
        it is set in italics,}
        \textsf{in a
        \emph{sans-serif} font,}
        \texttt{or in
        \emph{typewriter} style.}

      \subsection{An advice}
      \begin{center}
        \underline{\textbf{Remember\Huge!}} \textit{The}
        \textsf{M\textbf{\LARGE O} \texttt{R}\textsl{E}} fonts \Huge you
        \tiny use \footnotesize \textbf{in} a \small \texttt{document},
        \large \textit{the} \normalsize more \textsc{readable} and
        \textsl{\textsf{beautiful} it bec\large o\Large m\LARGE e\huge s}.
      \end{center}
    </textarea>

    <iframe id="preview" sandbox="allow-same-origin" srcdoc="<!DOCTYPE html>
      <html>
        <head>
          <link rel='stylesheet' type='text/css' href='css/article.css'>
          <link rel='stylesheet' type='text/css' href='css/katex.css'>

          <title>LaTeX preview</title>
        </head>

        <body>
        </body>
      </html>">
    </iframe>
  </div>

  <div id="footer">
    <div id="copyright">Copyright &copy; 2017 Michael Brade</div>
  </div>

  <script>

    /*  utility function: create a source excerpt  */
    function excerpt(txt, o) {
      var l = txt.length;
      var b = o - 20; if (b < 0) b = 0;
      var e = o + 20; if (e > l) e = l;
      var hex = function (ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      };
      var extract = function (txt, pos, len) {
        return txt.substr(pos, len)
          .replace(/\\/g,   "\\\\")
          .replace(/\x08/g, "\\b")
          .replace(/\t/g,   "\\t")
          .replace(/\n/g,   "\\n")
          .replace(/\f/g,   "\\f")
          .replace(/\r/g,   "\\r")
          .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return "\\x0" + hex(ch); })
          .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return "\\x"  + hex(ch); })
          .replace(/[\u0100-\u0FFF]/g,         function(ch) { return "\\u0" + hex(ch); })
          .replace(/[\u1000-\uFFFF]/g,         function(ch) { return "\\u"  + hex(ch); });
      };
      return {
        prolog: extract(txt, b, o - b),
        token:  extract(txt, o, 1),
        epilog: extract(txt, o + 1, e - (o + 1))
      };
    }

    /*  render a useful error message  */
    errorMessage = function (e, noFinalNewline) {
      var l = e.location;
      var prefix1 = "line " + e.line + " (column " + e.column + "): ";
      var prefix2 = "";
      for (var i = 0; i < prefix1.length + l.prolog.length; i++)
          prefix2 += "-";
      var msg = prefix1 + l.prolog + l.token + l.epilog + "\n" +
          prefix2 + "^" + "\n" +
          e.message + (noFinalNewline ? "" : "\n");
      return msg;
    };





    var textArea = document.getElementById('latex-editor')

    var editor = CodeMirror(function(el) {
      el.id = textArea.id;
      textArea.parentNode.replaceChild(el, textArea);
    }, {
      value: textArea.value.replace(/^      /mg, ''),
      mode: 'stex',
      theme: 'monokai',
      autofocus: true,
      lineWrapping: true,
      lineNumbers: true,
      tabSize: 4,
      indentUnit: 4
    })

    var preview = document.getElementById('preview')

    preview.addEventListener("load", function() {
      compile()
      editor.refresh()
    })

    var delay;
    editor.on('change', function(e) {
      //clearTimeout(delay)
      //delay = setTimeout(compile, 300)
      compile()
    })

    function compile() {
      var body = preview.contentDocument.body

      try {
        var options = {}
        var result = latexjs.parse(editor.getValue(), options)

        while (body.firstChild)
          body.removeChild(body.firstChild)

        body.appendChild(result.dom())
      } catch (e) {
        var error
        if (e instanceof latexjs.SyntaxError) {
          var definedOrElse = function (value, fallback) {
            return (typeof value !== "undefined" ? value : fallback);
          };
          error = {
            line:     definedOrElse(e.location.start.line, 0),
            column:   definedOrElse(e.location.start.column, 0),
            message:  e.message,
            found:    definedOrElse(e.found, ""),
            expected: definedOrElse(e.expected, ""),
            location: excerpt(editor.getValue(), definedOrElse(e.location.start.offset, 0))
          };

          body.innerHTML = "<pre>ERROR: Parsing failure:\n\n" + errorMessage(error, true) + "</pre>"
        } else {
          body.innerHTML = "<pre>ERROR: " + e.message + "</pre>";
        }
        console.error(e)
      }
    }
  </script>

  <script>
    Split(['#latex-editor', '#preview'], {
        elementStyle: function (dimension, size, gutterSize) {
            return { 'flex-basis': 'calc(' + size + '% - ' + gutterSize + 'px)' }
        },
        gutterStyle: function (dimension, gutterSize) {
            return { 'flex-basis':  gutterSize + 'px' }
        }
    });
  </script>
</body>

</html>
