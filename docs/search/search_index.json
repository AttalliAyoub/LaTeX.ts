{
    "docs": [
        {
            "location": "/",
            "text": "Convert LaTeX Documents to HTML5 in the Browser\n\n\nThis is a LaTeX to HTML5 translator written in JavaScript using PEG.js. \nlatex.js\n for LaTeX is similar in spirit\nto \nmarked\n for Markdown.\n\n\nLaTeX.js is absolutely and uncompromisingly exact and compatible with LaTeX, the generated HTML is exactly what\nis meant to be output, down to the last space. See the unit tests for examples and all the edge cases.\n\n\nYou can play with it here: \nhttp://michael-brade.github.io/LaTeX.js/playground.html\n\n\nUsage and Tests\n\n\nTo build it and run the tests, execute:\n\n\nnpm run build\nnpm test\n\n\n\n\nLaTeX.js only translates LaTeX's structure, you will have to write your CSS yourself or use some predefined CSS once I\nprovide it. You could think of a documentclass in LaTeX as a CSS file in LaTeX.js.\n\n\nLimitations\n\n\nThis is a PEG parser, which means it interprets LaTeX as a context-free language. However, TeX is Turing complete, so TeX\ncan only really be parsed by a complete Turing machine. It is not possible to parse the full TeX language with a static\nparser. See \nhere\n for some interesting\nexamples.\n\n\nIt is even undecidable wheather a TeX program has a parse tree. There has been done some research on the problem\nof parsing TeX, see \nhere\n.\n\n\nTo quote the four problems of TeX:\n\n\n\n\n\n\nSince TeX has dynamic scoping, it is not possible to determine statically wheather \na\n is an argument to \n\\app\n in \n\\app a\n\n  or just another letter. It depends on the definition of \n\\app\n at runtime.\n\n\n\n\n\n\nMacros can be passed as arguments to other macros, further complicating this problem. E.g.:\n  \ntex\n  \\def\\app #1 #2 {#1 #2}\n  \\def\\id #1 {#1}\n  \\app a b\n  \\app \\id c\n\n  Thus, targets of macro calls can in general not be determined statically.\n\n\n\n\n\n\nTeX has a lexical macro system, which means macro bodies do not have to be syntactically correct pieces of TeX code. Also,\n  macros can expand to new macro definitions.\n\n\n\n\n\n\nTex allows custom macro call syntax. Basically, any syntax could be changed.\n\n\n\n\n\n\nI therefore take a slightly different approach:\n\n\n\n\n\n\nFirst, I don't care about TeX, but only LaTeX, and most LaTeX documents do not use TeX syntax, or \n\\def\n in particular.\n  Therefore, this parser assumes standard LaTeX syntax and catcodes, and parses that statically.\n\n\n\n\n\n\nSecond, for now there is no way of defining macros, only expanding macros is supported. So if a new LaTeX macro is\n  needed, reimplement it in JavaScript directly, thus circumventing the problem altogether.\n\n\n\n\n\n\nThird, I don't care about formal correctness of my syntax tree. If a custom macro, say, takes only one argument and\n  \n\\foo{a}{b}\n is encountered, both arguments are passed to the JavaScript function \nfoo\n, which then leaves \nb\n\n  untouched, simply returning it along with its own result. This parser does not know about the arity of custom macros\n  (defined only in JavaScript), it assumes that the author of a macro call knows it. So ideally, macros should be\n  defined in the PEG.js grammar.\n\n\n\n\n\n\nExpansion and Execution\n\n\nAdditionally, this parser does not implement TeX's distinction of expansion and execution. I am not yet sure\nif I need to implement it at all. Right now, there is only one phase that takes a macro and returns an HTML fragment.\n\n\nSkipped spaces and macros that expand to a macro taking a parameter further down in the input provide a good\nillustration of why TeX makes this distinction. Consider the commands\n\n\n\\def\\a{\\penalty200}\n\\a 0\n\n\n\n\nThis is not equivalent to\n\n\n\\penalty200 0\n\n\n\n\nwhich would place a penalty of 200, and typeset the digit 0. Instead, it expands to\n\n\n\\penalty2000\n\n\n\n\nbecause the space after \\a is skipped in the input processor. Later stages of processing then receive the sequence\n\n\n\\a0\n\n\n\n\nHowever, LaTeX documents themselves usually don't rely on or need this feature--that is, until I'm convinced otherwise.\n\n\nTODO\n\n\nMaybe:\n\n\n\n\n[ ] implement the output using TeX's original linebreaking algorithm: https://github.com/bramstein/typeset\n\n\n\n\nAlternatives\n\n\nIf you need a more complete LaTeX to HTML translator that really understands TeX, take a look at\n\n\n\n\nLaTeXML\n (Perl) or\n\n\nHEVEA\n (OCaml) or\n\n\nplasTeX\n (Python).\n\n\n\n\nThere is no such alternative in JavaScript yet, though, which is why I started this project. I want to use it in my\n\nderby-entities-lib\n project.\n\n\nLicense\n\n\nMIT\n\n\nCopyright (c) 2015-2017 Michael Brade",
            "title": "Home"
        },
        {
            "location": "/#convert-latex-documents-to-html5-in-the-browser",
            "text": "This is a LaTeX to HTML5 translator written in JavaScript using PEG.js.  latex.js  for LaTeX is similar in spirit\nto  marked  for Markdown.  LaTeX.js is absolutely and uncompromisingly exact and compatible with LaTeX, the generated HTML is exactly what\nis meant to be output, down to the last space. See the unit tests for examples and all the edge cases.  You can play with it here:  http://michael-brade.github.io/LaTeX.js/playground.html",
            "title": "Convert LaTeX Documents to HTML5 in the Browser"
        },
        {
            "location": "/#usage-and-tests",
            "text": "To build it and run the tests, execute:  npm run build\nnpm test  LaTeX.js only translates LaTeX's structure, you will have to write your CSS yourself or use some predefined CSS once I\nprovide it. You could think of a documentclass in LaTeX as a CSS file in LaTeX.js.",
            "title": "Usage and Tests"
        },
        {
            "location": "/#limitations",
            "text": "This is a PEG parser, which means it interprets LaTeX as a context-free language. However, TeX is Turing complete, so TeX\ncan only really be parsed by a complete Turing machine. It is not possible to parse the full TeX language with a static\nparser. See  here  for some interesting\nexamples.  It is even undecidable wheather a TeX program has a parse tree. There has been done some research on the problem\nof parsing TeX, see  here .  To quote the four problems of TeX:    Since TeX has dynamic scoping, it is not possible to determine statically wheather  a  is an argument to  \\app  in  \\app a \n  or just another letter. It depends on the definition of  \\app  at runtime.    Macros can be passed as arguments to other macros, further complicating this problem. E.g.:\n   tex\n  \\def\\app #1 #2 {#1 #2}\n  \\def\\id #1 {#1}\n  \\app a b\n  \\app \\id c \n  Thus, targets of macro calls can in general not be determined statically.    TeX has a lexical macro system, which means macro bodies do not have to be syntactically correct pieces of TeX code. Also,\n  macros can expand to new macro definitions.    Tex allows custom macro call syntax. Basically, any syntax could be changed.    I therefore take a slightly different approach:    First, I don't care about TeX, but only LaTeX, and most LaTeX documents do not use TeX syntax, or  \\def  in particular.\n  Therefore, this parser assumes standard LaTeX syntax and catcodes, and parses that statically.    Second, for now there is no way of defining macros, only expanding macros is supported. So if a new LaTeX macro is\n  needed, reimplement it in JavaScript directly, thus circumventing the problem altogether.    Third, I don't care about formal correctness of my syntax tree. If a custom macro, say, takes only one argument and\n   \\foo{a}{b}  is encountered, both arguments are passed to the JavaScript function  foo , which then leaves  b \n  untouched, simply returning it along with its own result. This parser does not know about the arity of custom macros\n  (defined only in JavaScript), it assumes that the author of a macro call knows it. So ideally, macros should be\n  defined in the PEG.js grammar.",
            "title": "Limitations"
        },
        {
            "location": "/#expansion-and-execution",
            "text": "Additionally, this parser does not implement TeX's distinction of expansion and execution. I am not yet sure\nif I need to implement it at all. Right now, there is only one phase that takes a macro and returns an HTML fragment.  Skipped spaces and macros that expand to a macro taking a parameter further down in the input provide a good\nillustration of why TeX makes this distinction. Consider the commands  \\def\\a{\\penalty200}\n\\a 0  This is not equivalent to  \\penalty200 0  which would place a penalty of 200, and typeset the digit 0. Instead, it expands to  \\penalty2000  because the space after \\a is skipped in the input processor. Later stages of processing then receive the sequence  \\a0  However, LaTeX documents themselves usually don't rely on or need this feature--that is, until I'm convinced otherwise.",
            "title": "Expansion and Execution"
        },
        {
            "location": "/#todo",
            "text": "Maybe:   [ ] implement the output using TeX's original linebreaking algorithm: https://github.com/bramstein/typeset",
            "title": "TODO"
        },
        {
            "location": "/#alternatives",
            "text": "If you need a more complete LaTeX to HTML translator that really understands TeX, take a look at   LaTeXML  (Perl) or  HEVEA  (OCaml) or  plasTeX  (Python).   There is no such alternative in JavaScript yet, though, which is why I started this project. I want to use it in my derby-entities-lib  project.",
            "title": "Alternatives"
        },
        {
            "location": "/#license",
            "text": "MIT  Copyright (c) 2015-2017 Michael Brade",
            "title": "License"
        }
    ]
}